using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityStandardAssets.Characters.FirstPerson;
using System.Linq;

public partial class IK_Robot_Arm_Controller : ArmController {
    [SerializeField]
    private Transform armBase, elbowTarget, handCameraTransform, FirstJoint;

    private PhysicsRemoteFPSAgentController PhysicsController;

    // dict to track which picked up object has which set of trigger colliders
    // which we have to parent and reparent in order for arm collision to detect
    [SerializeField]
    public new Dictionary<SimObjPhysics, HashSet<Collider>> heldObjects = new Dictionary<SimObjPhysics, HashSet<Collider>>();

    // private bool StopMotionOnContact = false;
    // Start is called before the first frame update

    private FK_IK_Solver solver;

    private float originToShoulderLength = 0f;

    private const float extendedArmLength = 0.6325f;

    public override GameObject GetArmTarget() {
        return armTarget.gameObject;
    }

     public override Transform pickupParent() {
        return magnetSphere.transform;
    }

    public override Vector3  wristSpaceOffsetToWorldPos(Vector3 offset) {
        return handCameraTransform.TransformPoint(offset) - handCameraTransform.TransformPoint(Vector3.zero);
    }
    public override Vector3 armBaseSpaceOffsetToWorldPos(Vector3 offset) {
        return this.transform.TransformPoint(offset) - this.transform.TransformPoint(Vector3.zero);
    }

    public override Vector3 pointToWristSpace(Vector3 point) {
        return handCameraTransform.TransformPoint(point);
    }
    public override Vector3 pointToArmBaseSpace(Vector3 point) {
        return this.transform.Find("robot_arm_FK_IK_rig").transform.TransformPoint(point);
    }

    public override void manipulateArm() {
        solver.ManipulateArm();
    }

    public GameObject GetArmBase() {
        return armBase.gameObject;
    }

    
    public GameObject GetElbowTarget() {
        return elbowTarget.gameObject;
    }

    public GameObject GetMagnetSphere() {
        return magnetSphere.gameObject;
    }

    protected override void resetArmTarget() {
        Vector3 pos = handCameraTransform.transform.position;
        Quaternion rot = handCameraTransform.transform.rotation;
        armTarget.position = pos;
        armTarget.rotation = rot;
    }

   
    void Start() {
        // calculating based on distance from origin of arm to the 2nd joint, which will always be constant
        this.originToShoulderLength = Vector3.Distance(
            this.transform.FirstChildOrDefault(
                x => x.name == "robot_arm_2_jnt"
            ).position,
            this.transform.position
        );

        this.collisionListener = this.GetComponentInParent<CollisionListener>();
        this.collisionListener.registerAllChildColliders();

        List<CapsuleCollider> armCaps = new List<CapsuleCollider>();
        List<BoxCollider> armBoxes = new List<BoxCollider>();

        // get references to all colliders in arm. Remove trigger colliders so there are no duplicates when using these as reference for
        // overlap casts since the trigger colliders are themselves duplicates of the nontrigger colliders.
        armCaps.AddRange(gameObject.GetComponentsInChildren<CapsuleCollider>());
        armBoxes.AddRange(gameObject.GetComponentsInChildren<BoxCollider>());

        // clean up arm colliders, removing triggers
        List<CapsuleCollider> cleanedCaps = new List<CapsuleCollider>();
        foreach (CapsuleCollider c in armCaps) {
            if (!c.isTrigger) {
                cleanedCaps.Add(c);
            }
        }

        ArmCapsuleColliders = cleanedCaps.ToArray();

        List<BoxCollider> cleanedBoxes = new List<BoxCollider>();
        foreach (BoxCollider b in armBoxes) {
            if (!b.isTrigger) {
                cleanedBoxes.Add(b);
            }
        }

        ArmBoxColliders = cleanedBoxes.ToArray();

        // TODO: Currently explicitly ignoring all arm self collisions (for efficiency)!
        var colliders = this.GetComponentsInChildren<Collider>();
        foreach (Collider c0 in colliders) {
            foreach (Collider c1 in colliders) {
                Physics.IgnoreCollision(c0, c1);
            }
        }
        solver = this.gameObject.GetComponentInChildren<FK_IK_Solver>();
    }

    // Restricts front hemisphere for arm movement
    protected override bool validArmTargetPosition(Vector3 targetWorldPosition) {
        Vector3 targetShoulderSpace = (
            this.transform.InverseTransformPoint(targetWorldPosition)
            - new Vector3(0, 0, originToShoulderLength)
        );

        // check if not behind, check if not hyper extended
        return targetShoulderSpace.z >= 0.0f && targetShoulderSpace.magnitude <= extendedArmLength;
    }

<<<<<<< HEAD
=======
    protected IEnumerator resetArmTargetPositionRotationAsLastStep(IEnumerator steps) {
        // IEnumerator last = null;
        while (steps.MoveNext()) {
            yield return steps.Current;
        }
        Vector3 pos = handCameraTransform.transform.position;
        Quaternion rot = handCameraTransform.transform.rotation;
        armTarget.position = pos;
        armTarget.rotation = rot;
    }

    protected IEnumerator resetArmTargetPositionRotationEnumerator() {
        yield return null;
        Vector3 pos = handCameraTransform.transform.position;
        Quaternion rot = handCameraTransform.transform.rotation;
        armTarget.position = pos;
        armTarget.rotation = rot;
    }


    /*
    See the documentation of the `MoveArmRelative` function
    in the ArmAgentController.
    */
    public void moveArmRelative(
        PhysicsRemoteFPSAgentController controller,
        Vector3 offset,
        float unitsPerSecond,
        float fixedDeltaTime = 0.02f,
        bool returnToStart = false,
        string coordinateSpace = "arm",
        bool restrictTargetPosition = false,
        bool disableRendering = false
    ) {

        Vector3 offsetWorldPos;
        switch (coordinateSpace) {
            case "world":
                // world space, can be used to move directly toward positions
                // returned by sim objects
                offsetWorldPos = offset;
                break;
            case "wrist":
                // space relative to base of the wrist, where the camera is
                offsetWorldPos = handCameraTransform.TransformPoint(offset) - handCameraTransform.TransformPoint(Vector3.zero);
                break;
            case "armBase":
                // space relative to the root of the arm, joint 1
                offsetWorldPos = this.transform.TransformPoint(offset) - this.transform.TransformPoint(Vector3.zero);
                break;
            default:
                throw new ArgumentException("Invalid coordinateSpace: " + coordinateSpace);
        }
        moveArmTarget(
            controller: controller,
            target: armTarget.position + offsetWorldPos,
            unitsPerSecond: unitsPerSecond,
            fixedDeltaTime: fixedDeltaTime,
            returnToStart: returnToStart,
            coordinateSpace: "world",
            restrictTargetPosition: restrictTargetPosition,
            disableRendering: disableRendering
        );
    }

     public IEnumerator moveArmTargetNew(
        PhysicsRemoteFPSAgentController controller,
        Vector3 target,
        float unitsPerSecond,
        float fixedDeltaTime = 0.02f,
        bool returnToStart = false,
        string coordinateSpace = "armBase",
        bool restrictTargetPosition = false
    ) {
        Debug.Log("---- IKROBO moveNEW start");
         // clearing out colliders here since OnTriggerExit is not consistently called in Editor
        collisionListener.Reset();

        IK_Robot_Arm_Controller arm = this;

        // Move arm based on hand space or arm origin space
        Vector3 targetWorldPos;
        switch (coordinateSpace) {
            case "world":
                // world space, can be used to move directly toward positions
                // returned by sim objects
                targetWorldPos = target;
                break;
            case "wrist":
                // space relative to base of the wrist, where the camera is
                targetWorldPos = handCameraTransform.TransformPoint(target);
                break;
            case "armBase":
                // space relative to the root of the arm, joint 1
                targetWorldPos = arm.transform.Find("robot_arm_FK_IK_rig").transform.TransformPoint(target);
                break;
            default:
                throw new ArgumentException("Invalid coordinateSpace: " + coordinateSpace);
        }

        // TODO Remove this after restrict movement is finalized
        Vector3 targetShoulderSpace = (this.transform.InverseTransformPoint(targetWorldPos) - new Vector3(0, 0, originToShoulderLength));

#if UNITY_EDITOR
        Debug.Log(
            $"pos target {target} world {targetWorldPos} remaining {targetShoulderSpace.z}\n" +
            $"magnitude {targetShoulderSpace.magnitude} extendedArmLength {extendedArmLength}"
        );
#endif

        if (restrictTargetPosition && !validArmTargetPosition(targetWorldPos)) {
            targetShoulderSpace = (
                this.transform.InverseTransformPoint(targetWorldPos)
                - new Vector3(0, 0, originToShoulderLength)
            );
            throw new InvalidOperationException(
                $"Invalid target: Position '{target}' in space '{coordinateSpace}' is behind shoulder."
            );
        }

        // yield return resetArmTargetPositionRotationAsLastStep(
        //     ContinuousMovement.moveNew(
        //         controller,
        //         collisionListener,
        //         armTarget,
        //         targetWorldPos,
        //         fixedDeltaTime,
        //         unitsPerSecond,
        //         returnToStart,
        //         false
        //     )
        // );

        Debug.Log("--- IK_ROBOT ARM calling moveNEW");

        return resetArmTargetPositionRotationAsLastStep(
            ContinuousMovement.moveNew(
                controller,
                collisionListener,
                armTarget,
                targetWorldPos,
                fixedDeltaTime,
                unitsPerSecond,
                returnToStart,
                false
            )
        );

    }

    public void moveArmTarget(
        PhysicsRemoteFPSAgentController controller,
        Vector3 target,
        float unitsPerSecond,
        float fixedDeltaTime = 0.02f,
        bool returnToStart = false,
        string coordinateSpace = "arm",
        bool restrictTargetPosition = false,
        bool disableRendering = false
    ) {
        // clearing out colliders here since OnTriggerExit is not consistently called in Editor
        collisionListener.Reset();

        IK_Robot_Arm_Controller arm = this;

        // Move arm based on hand space or arm origin space
        Vector3 targetWorldPos;
        switch (coordinateSpace) {
            case "world":
                // world space, can be used to move directly toward positions
                // returned by sim objects
                targetWorldPos = target;
                break;
            case "wrist":
                // space relative to base of the wrist, where the camera is
                targetWorldPos = handCameraTransform.TransformPoint(target);
                break;
            case "armBase":
                // space relative to the root of the arm, joint 1
                targetWorldPos = arm.transform.Find("robot_arm_FK_IK_rig").transform.TransformPoint(target);
                break;
            default:
                throw new ArgumentException("Invalid coordinateSpace: " + coordinateSpace);
        }

        // TODO Remove this after restrict movement is finalized
        Vector3 targetShoulderSpace = (this.transform.InverseTransformPoint(targetWorldPos) - new Vector3(0, 0, originToShoulderLength));

#if UNITY_EDITOR
        Debug.Log(
            $"pos target {target} world {targetWorldPos} remaining {targetShoulderSpace.z}\n" +
            $"magnitude {targetShoulderSpace.magnitude} extendedArmLength {extendedArmLength}"
        );
#endif

        if (restrictTargetPosition && !validArmTargetPosition(targetWorldPos)) {
            targetShoulderSpace = (
                this.transform.InverseTransformPoint(targetWorldPos)
                - new Vector3(0, 0, originToShoulderLength)
            );
            throw new InvalidOperationException(
                $"Invalid target: Position '{target}' in space '{coordinateSpace}' is behind shoulder."
            );
        }

        IEnumerator moveCall = resetArmTargetPositionRotationAsLastStep(
            ContinuousMovement.move(
                controller,
                collisionListener,
                armTarget,
                targetWorldPos,
                disableRendering ? fixedDeltaTime : Time.fixedDeltaTime,
                unitsPerSecond,
                returnToStart,
                false
            )
        );

        if (disableRendering) {
            controller.unrollSimulatePhysics(
                moveCall,
                fixedDeltaTime
            );
        } else {
            StartCoroutine(
                moveCall
            );
        }
    }

    public void moveArmBase(
        PhysicsRemoteFPSAgentController controller,
        float height,
        float unitsPerSecond,
        float fixedDeltaTime = 0.02f,
        bool returnToStartPositionIfFailed = false,
        bool disableRendering = false,
        bool normalizedY = true
    ) {
        // clearing out colliders here since OnTriggerExit is not consistently called in Editor
        collisionListener.Reset();

        CapsuleCollider cc = controller.GetComponent<CapsuleCollider>();
        Vector3 capsuleWorldCenter = cc.transform.TransformPoint(cc.center);

        float maxY = capsuleWorldCenter.y + cc.height / 2f;
        float minY = capsuleWorldCenter.y + (-cc.height / 2f) / 2f;

        if (normalizedY) {
            height = (maxY - minY) * height + minY;
        }

        if (height < minY || height > maxY) {
            throw new ArgumentOutOfRangeException($"height={height} value must be in [{minY}, {maxY}].");
        }

        Vector3 target = new Vector3(this.transform.position.x, height, this.transform.position.z);
        IEnumerator moveCall = resetArmTargetPositionRotationAsLastStep(
                ContinuousMovement.move(
                controller: controller,
                collisionListener: collisionListener,
                moveTransform: this.transform,
                targetPosition: target,
                fixedDeltaTime: disableRendering ? fixedDeltaTime : Time.fixedDeltaTime,
                unitsPerSecond: unitsPerSecond,
                returnToStartPropIfFailed: returnToStartPositionIfFailed,
                localPosition: false
            )
        );

        if (disableRendering) {
            controller.unrollSimulatePhysics(
                enumerator: moveCall,
                fixedDeltaTime: fixedDeltaTime
            );
        } else {
            StartCoroutine(moveCall);
        }
    }

    public IEnumerator moveArmBaseNew(
        PhysicsRemoteFPSAgentController controller,
        float height,
        float unitsPerSecond,
        float fixedDeltaTime = 0.02f,
        bool returnToStartPositionIfFailed = false,
        bool normalizedY = true
    ) {
        // clearing out colliders here since OnTriggerExit is not consistently called in Editor
        collisionListener.Reset();

        CapsuleCollider cc = controller.GetComponent<CapsuleCollider>();
        Vector3 capsuleWorldCenter = cc.transform.TransformPoint(cc.center);

        float maxY = capsuleWorldCenter.y + cc.height / 2f;
        float minY = capsuleWorldCenter.y + (-cc.height / 2f) / 2f;

        if (normalizedY) {
            height = (maxY - minY) * height + minY;
        }

        if (height < minY || height > maxY) {
            throw new ArgumentOutOfRangeException($"height={height} value must be in [{minY}, {maxY}].");
        }

        Vector3 target = new Vector3(this.transform.position.x, height, this.transform.position.z);
        return resetArmTargetPositionRotationAsLastStep(
                ContinuousMovement.moveNew(
                controller: controller,
                collisionListener: collisionListener,
                moveTransform: this.transform,
                targetPosition: target,
                fixedDeltaTime: fixedDeltaTime,
                unitsPerSecond: unitsPerSecond,
                returnToStartPropIfFailed: returnToStartPositionIfFailed,
                localPosition: false
            )
        );
    }

    public void moveArmBaseUp(
        PhysicsRemoteFPSAgentController controller,
        float distance,
        float unitsPerSecond,
        float fixedDeltaTime = 0.02f,
        bool returnToStartPositionIfFailed = false,
        bool disableRendering = false
    ) {
        // clearing out colliders here since OnTriggerExit is not consistently called in Editor
        collisionListener.Reset();

        CapsuleCollider cc = controller.GetComponent<CapsuleCollider>();
        Vector3 capsuleWorldCenter = cc.transform.TransformPoint(cc.center);
        float maxY = capsuleWorldCenter.y + cc.height / 2f;
        float minY = capsuleWorldCenter.y + (-cc.height / 2f) / 2f;
        float targetY = this.transform.position.y + distance;
        targetY = Mathf.Max(Mathf.Min(targetY, maxY), minY);

        moveArmBase(
            controller: controller,
            height: targetY,
            unitsPerSecond: unitsPerSecond,
            fixedDeltaTime: fixedDeltaTime,
            returnToStartPositionIfFailed: returnToStartPositionIfFailed,
            disableRendering: disableRendering,
            normalizedY: false
        );
    }

>>>>>>> physics-determinism
    public void rotateWristAroundPoint(
        PhysicsRemoteFPSAgentController controller,
        Vector3 rotatePoint,
        Quaternion rotation,
        float degreesPerSecond,
        bool disableRendering = false,
        float fixedDeltaTime = 0.02f,
        bool returnToStartPositionIfFailed = false
    ) {
        collisionListener.Reset();
        IEnumerator rotate = resetArmTargetPositionRotationAsLastStep(
            ContinuousMovement.rotateAroundPoint(
                controller: controller,
                collisionListener: collisionListener,
                updateTransform: armTarget.transform,
                rotatePoint: rotatePoint,
                targetRotation: rotation,
                fixedDeltaTime: disableRendering ? fixedDeltaTime : Time.fixedDeltaTime,
                degreesPerSecond: degreesPerSecond,
                returnToStartPropIfFailed: returnToStartPositionIfFailed
            )
        );

        if (disableRendering) {
            controller.unrollSimulatePhysics(
                rotate,
                fixedDeltaTime
            );
        } else {
            StartCoroutine(rotate);
        }
    }

    public void rotateElbowRelative(
        PhysicsRemoteFPSAgentController controller,
        float degrees,
        float degreesPerSecond,
        bool disableRendering = false,
        float fixedDeltaTime = 0.02f,
        bool returnToStartPositionIfFailed = false
    ) {
        collisionListener.Reset();
        GameObject poleManipulator = GameObject.Find("IK_pole_manipulator");
        Quaternion rotation = Quaternion.Euler(0f, 0f, degrees);
        IEnumerator rotate = resetArmTargetPositionRotationAsLastStep(
            ContinuousMovement.rotate(
                controller,
                collisionListener,
                poleManipulator.transform,
                poleManipulator.transform.rotation * rotation,
                disableRendering ? fixedDeltaTime : Time.fixedDeltaTime,
                degreesPerSecond,
                returnToStartPositionIfFailed
            )
        );

        if (disableRendering) {
            controller.unrollSimulatePhysics(
                rotate,
                fixedDeltaTime
            );
        } else {
            StartCoroutine(rotate);
        }
    }

    public void rotateElbow(
        PhysicsRemoteFPSAgentController controller,
        float degrees,
        float degreesPerSecond,
        bool disableRendering = false,
        float fixedDeltaTime = 0.02f,
        bool returnToStartPositionIfFailed = false
    ) {
        GameObject poleManipulator = GameObject.Find("IK_pole_manipulator");
        rotateElbowRelative(
            controller: controller,
            degrees: (degrees - poleManipulator.transform.eulerAngles.z),
            degreesPerSecond: degreesPerSecond,
            disableRendering: disableRendering,
            fixedDeltaTime: fixedDeltaTime,
            returnToStartPositionIfFailed: returnToStartPositionIfFailed
        );
    }

    public override ArmMetadata GenerateMetadata() {
        ArmMetadata meta = new ArmMetadata();
        // meta.handTarget = armTarget.position;
        Transform joint = transform;
        List<JointMetadata> joints = new List<JointMetadata>();

        // Declare variables used for processing metadata
        Transform parentJoint;
        float angleRot;
        Vector3 vectorRot;
        Quaternion currentRotation;

        // Assign joint metadata to remaining joints, which all have identical hierarchies
        for (int i = 1; i <= 4; i++) {
            joint = joint.Find("robot_arm_" + i + "_jnt");

            JointMetadata jointMeta = new JointMetadata();

            // JOINT NAME
            jointMeta.name = joint.name;

            // POSITIONS //

            // WORLD RELATIVE POSITION
            jointMeta.position = joint.position;

            // ROOT-JOINT RELATIVE POSITION
            // Parent-relative position of joint is meaningless because it never changes relative to its parent joint, so we use rootRelative instead
            jointMeta.rootRelativePosition = FirstJoint.InverseTransformPoint(joint.position);

            // ROTATIONS //

            // WORLD RELATIVE ROTATION
            // Angler is grabbed since that is what actually changes the geometry angle
            currentRotation = joint.GetChild(0).rotation;

            // Check that world-relative rotation is angle-axis-notation-compatible
            if (currentRotation != new Quaternion(0, 0, 0, -1)) {
                currentRotation.ToAngleAxis(angle: out angleRot, axis: out vectorRot);

                jointMeta.rotation = new Vector4(vectorRot.x, vectorRot.y, vectorRot.z, angleRot);
            } else {
                jointMeta.rotation = new Vector4(1, 0, 0, 0);
            }

            // ROOT-JOINT RELATIVE ROTATION
            // Root-forward and agent-forward are always the same

            // Grab rotation of current joint's angler relative to root joint
            currentRotation = Quaternion.Inverse(armBase.rotation) * joint.GetChild(0).rotation;

            // Check that root-relative rotation is angle-axis-notation-compatible
            if (currentRotation != new Quaternion(0, 0, 0, -1)) {
                currentRotation.ToAngleAxis(angle: out angleRot, axis: out vectorRot);
                jointMeta.rootRelativeRotation = new Vector4(vectorRot.x, vectorRot.y, vectorRot.z, angleRot);
            } else {
                jointMeta.rootRelativeRotation = new Vector4(1, 0, 0, 0);
            }

            // PARENT-JOINT RELATIVE ROTATION
            if (i != 1) {
                parentJoint = joint.parent;

                // Grab rotation of current joint's angler relative to parent joint's angler
                currentRotation = Quaternion.Inverse(parentJoint.GetChild(0).rotation) * joint.GetChild(0).rotation;

                // Check that parent-relative rotation is angle-axis-notation-compatible
                if (currentRotation != new Quaternion(0, 0, 0, -1)) {
                    currentRotation.ToAngleAxis(angle: out angleRot, axis: out vectorRot);
                    jointMeta.localRotation = new Vector4(vectorRot.x, vectorRot.y, vectorRot.z, angleRot);
                } else {
                    jointMeta.localRotation = new Vector4(1, 0, 0, 0);
                }
            } else {
                // Special case for robot_arm_1_jnt because it has no parent-joint
                jointMeta.localRotation = jointMeta.rootRelativeRotation;

                jointMeta.armBaseHeight = this.transform.localPosition.y;
                jointMeta.elbowOrientation = elbowTarget.localEulerAngles.z;
            }

            joints.Add(jointMeta);
        }

        meta.joints = joints.ToArray();

        // metadata for any objects currently held by the hand on the arm
        // note this is different from objects intersecting the hand's sphere,
        // there could be a case where an object is inside the sphere but not picked up by the hand
        List<string> heldObjectIDs = new List<string>();
        if (heldObjects != null) {
            foreach (SimObjPhysics sop in heldObjects.Keys) {
                heldObjectIDs.Add(sop.objectID);
            }
        }

        meta.heldObjects = heldObjectIDs;
        meta.handSphereCenter = magnetSphere.transform.TransformPoint(magnetSphere.center);
        meta.handSphereRadius = magnetSphere.radius;
        List<SimObjPhysics> objectsInMagnet = WhatObjectsAreInsideMagnetSphereAsSOP(false);
        meta.pickupableObjects = objectsInMagnet.Where(
            x => x.PrimaryProperty == SimObjPrimaryProperty.CanPickup
        ).Select(x => x.ObjectID).ToList();
        meta.touchedNotHeldObjects = objectsInMagnet.Select(x => x.ObjectID).ToList();
        return meta;
    }

#if UNITY_EDITOR
    public class GizmoDrawCapsule {
        public Vector3 p0;
        public Vector3 p1;
        public float radius;
    }

    List<GizmoDrawCapsule> debugCapsules = new List<GizmoDrawCapsule>();

    private void OnDrawGizmos() {
        if (debugCapsules.Count > 0) {
            foreach (GizmoDrawCapsule thing in debugCapsules) {
                Gizmos.DrawWireSphere(thing.p0, thing.radius);
                Gizmos.DrawWireSphere(thing.p1, thing.radius);
            }
        }
    }
#endif
}
